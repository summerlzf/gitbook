# Java类加载机制：双亲委派模型

#### 由上到下的类加载器：

- 启动类加载器（Bootstrap ClassLoader）
- 扩展类加载器（Extension ClassLoader）
- 应用类加载器（Application ClassLoader）
- 自定义类加载器

双亲委派模型的本质：确保所在层级的类被正确加载（最终实现的统一）



# Java内存模型（JMM）

在Java中，使用 <u>共享内存模型</u> 来实现多线程之间的信息交换和数据同步

JVM的运行时数据区包含以下几个内存区域：

- PC寄存器 / 程序计数器：用于保存当前正在执行的程序的内存地址，每个线程都有独立的程序计数器，线程间计数器互不影响，独立存储，是线程安全的

- Java栈（Stack）：总是与线程关联在一起，每当一个线程被创建，JVM就会为该线程创建对应的栈，因此栈数据是线程私有的，不存在数据同步和一致性问题，是线程安全的；在JVM规范中，关于栈有以下两种异常情况：
  
  1. 如果线程请求的栈深度大于虚拟机允许的深度，会抛出 `StackOverflowError` 异常
  
  2. 如果JVM可以动态扩展，而又无法申请到足够的内存时，会抛出 `OutOfMemoryError` 异常
  
  在HotSpot VM中，-Xss 参数用来设置栈的大小；栈的大小直接决定了方法调用的可达深度
  
- 堆（Heap）：用来存储Java对象的地方，是JVM管理的内存中最大的一块，堆内存被所有Java线程共享，因此是线程不安全的；根据JVM规范，所有的对象实例和数组都需要在堆上分配，是GC管理的主要区域

- 方法区：主要存放了类的信息（名称、修饰符等）、类中的静态常量、final类型常量、类的Field信息、方法信息；方法区的数据是被Java线程所共享的；方法区是堆中的一部分，也就是堆中的永久区，其大小可通过参数来设置：-XX:PermSize 指定初始值，-XX:MaxPermSize 指定最大值

- 常量池：是方法区中的一个数据结构，存储了如字符串、final变量值、类名和方法名常量；常量池在编译期间就已经被确定，保存在已编译的.class文件中

- 本地方法栈：与Java栈的作用类似，区别是：Java栈为JVM执行Java方法服务，本地方法栈则是为JVM执行native方法服务

##### JMM的主要目标是定义程序中各个变量的访问规则，即JVM将变量写入内存以及从内存中读取变量的底层细节

JMM规定所有的变量都存储在主内存（Main Memory）中，每个线程有自己的工作内存（Work Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量（声明为volatile的变量仍然有工作内存的拷贝，但特殊的操作顺序性，使其看起来跟直接读写主内存一样）；不同的线程之间无法直接访问对方的工作内存，线程间的数据传递都需要通过主内存完成

JMM主要围绕并发编程中的三个特性建立的：原子性、可见性、有序性

- 原子性：一个操作不能被打断，要么全部执行完毕，要么不执行
- 可见性：一个线程对共享变量修改以后，其它线程能够立刻看到（感知到）该变量的变化
- 有序性：顺序执行线程中的代码（单线程是如此，但多线程有可能是乱序的，即可能发生“指令重排”和“工作内存和主内存同步延迟”现象）

JMM通过将工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存，这种依赖主内存的方式实现【可见性】，无论是普通变量还是volatile变量，都是如此；但volatile变量的特殊规则使其修改后的值能立刻同步到主内存，使用时能立刻从主内存中刷新，保证了多线程操作volatile变量时的【可见性】，普通变量则无法保证这一点；synchronized、final、Lock同样能够保证【可见性】

volatile和synchronized都可以保证多线程操作的【有序性】，volatile通过加入内存屏障来禁止指令的重排序，而synchronized通过对变量在同一时间内只允许一个线程加锁的规则实现的



# 垃圾回收（GC）机制

有关GC的讨论，以目前市面上使用最广泛的Java虚拟机——HotSpot VM为例进行说明，如果没有特殊说明，其都为HotSpot VM的特性

堆（Heap）是JVM进行垃圾回收的主要场所，其次的场所是方法区

JVM将堆分为新生代（Young Generation）和老年代（Old Generation），而新生代又分为：Eden区、From Survivor区、To Survivor区，Eden区占据较大的内存区域；当GC发生时，会将Eden和From Survivor中存活的对象复制到To Survivor区，然后清理Eden和From Survivor区

- 新生代（Young Generation）：所有新创建的对象都是用新生代分配内存，Eden空间不足时，会触发Minor GC，把存活对象转移到Survivor中去
- 老年代（Old Generation）：用于存放经过多次Minor GC后依然存活的对象，这些对象有存活时间长、比较稳定等特点
- 永久代（Perm Generation）：堆中的方法区在GC内存划分中通常被称为永久代，其中保存的对象一般不会被回收

### 垃圾回收算法

1. Mark-Sweep（标记-清除）算法：最基础的垃圾回收算法，思路简单，容易实现；算法分为两个阶段：标记阶段和清除阶段，标记阶段主要标记需要被回收的对象，清除阶段就是回收被标记的对象所占用的内存空间；缺点是会产生内存碎片，太多的内存碎片会导致后续需要分配大对象时找不到足够的空间，从而触发新的垃圾回收动作
2. Copying（复制）算法：用于解决Mark-Sweep算法的缺陷，将内存按可用容量大小划分为两等份，每次只使用其中的一块，当一块用完了，就将存活的对象复制到另一块上，再把已使用的这块内存空间一次性清理掉，这就解决了内存碎片的问题；缺点同样很明显，内存的使用率缩减到原来的一半
3. Mark-Compact（标记-整理）算法：



# Java动态代理和cglib实现

JDK动态代理：通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法
cglib实现：通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理



# HashMap

HashMap是无序的
Map的有序实现类：TreeMap、LinkedHashMap