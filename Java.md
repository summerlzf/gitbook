# Java类加载机制：双亲委派模型

#### 由上到下的类加载器：

- 启动类加载器（Bootstrap ClassLoader）
- 扩展类加载器（Extension ClassLoader）
- 应用类加载器（Application ClassLoader）
- 自定义类加载器

双亲委派模型的本质：确保所在层级的类被正确加载（最终实现的统一）



# Java内存模型（JMM）

在Java中，使用 <u>共享内存模型</u> 来实现多线程之间的信息交换和数据同步

JVM的运行时数据区包含以下几个内存区域：

- PC寄存器 / 程序计数器：用于保存当前正在执行的程序的内存地址，每个线程都有独立的程序计数器，线程间计数器互不影响，独立存储，是线程安全的

- Java栈（Stack）：总是与线程关联在一起，每当一个线程被创建，JVM就会为该线程创建对应的栈，因此栈数据是线程私有的，不存在数据同步和一致性问题，是线程安全的；在JVM规范中，关于栈有以下两种异常情况：
  
  1. 如果线程请求的栈深度大于虚拟机允许的深度，会抛出 `StackOverflowError` 异常
  
  2. 如果JVM可以动态扩展，而又无法申请到足够的内存时，会抛出 `OutOfMemoryError` 异常
  
  在HotSpot VM中，-Xss 参数用来设置栈的大小；栈的大小直接决定了方法调用的可达深度
  
- 堆（Heap）：用来存储Java对象的地方，是JVM管理的内存中最大的一块，堆内存被所有Java线程共享，因此是线程不安全的；根据JVM规范，所有的对象实例和数组都需要在堆上分配，是GC管理的主要区域

- 方法区：主要存放了类的信息（名称、修饰符等）、类中的静态常量、final类型常量、类的Field信息、方法信息；方法区的数据是被Java线程所共享的；方法区是堆中的一部分，也就是堆中的永久区，其大小可通过参数来设置：-XX:PermSize 指定初始值，-XX:MaxPermSize 指定最大值

- 常量池：是方法区中的一个数据结构，存储了如字符串、final变量值、类名和方法名常量；常量池在编译期间就已经被确定，保存在已编译的.class文件中

- 本地方法栈：与Java栈的作用类似，区别是：Java栈为JVM执行Java方法服务，本地方法栈则是为JVM执行native方法服务

##### JMM的主要目标是定义程序中各个变量的访问规则，即JVM将变量写入内存以及从内存中读取变量的底层细节

JMM规定所有的变量都存储在主内存（Main Memory）中，每个线程有自己的工作内存（Work Memory），线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量（声明为volatile的变量仍然有工作内存的拷贝，但特殊的操作顺序性，使其看起来跟直接读写主内存一样）；不同的线程之间无法直接访问对方的工作内存，线程间的数据传递都需要通过主内存完成

JMM主要围绕并发编程中的三个特性建立的：原子性、可见性、有序性

- 原子性：一个操作不能被打断，要么全部执行完毕，要么不执行
- 可见性：一个线程对共享变量修改以后，其它线程能够立刻看到（感知到）该变量的变化
- 有序性：顺序执行线程中的代码（单线程是如此，但多线程有可能是乱序的，即可能发生“指令重排”和“工作内存和主内存同步延迟”现象）

JMM通过将工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存，这种依赖主内存的方式实现【可见性】，无论是普通变量还是volatile变量，都是如此；但volatile变量的特殊规则使其修改后的值能立刻同步到主内存，使用时能立刻从主内存中刷新，保证了多线程操作volatile变量时的【可见性】，普通变量则无法保证这一点；synchronized、final、Lock同样能够保证【可见性】

volatile和synchronized都可以保证多线程操作的【有序性】，volatile通过加入内存屏障来禁止指令的重排序，而synchronized通过对变量在同一时间内只允许一个线程加锁的规则实现的



# 垃圾回收（GC）机制

【待续】



# Java动态代理和cglib实现

JDK动态代理：通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法
cglib实现：通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理



# HashMap

HashMap是无序的
Map的有序实现类：TreeMap、LinkedHashMap