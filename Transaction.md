# 事务的四个特性（ACID）

#### 原子性（Atomicity）

要么全部执行成功，要么全部不执行，只要其中一条指令失败，所有执行失败，数据进行回滚，回到执行前的状态

#### 一致性（Consistency）

事务的执行使数据从一种状态转换为另一种状态，但是对于整个数据的完整性保持稳定

#### 隔离性（Isolation）

当多个用户并发访问数据库，如访问同一张表时，数据库为每个用户开启的事务，不能被其它事务的操作所干扰，多个并发事务之间要相互隔离

#### 持久性（Durability）

当事务执行完成后，它对于数据的改变是永久性的



# 并发事务导致的问题

#### 丢失更新

- 情况一：撤销一个事务时，把其他事务已提交的更新数据覆盖
- 情况二：不可重复读的特殊情况，两个事务同时读取了同一条数据，然后都进行了写操作，并提交，第一个事务所作的改变就会丢失

#### 脏读

在一个事务处理过程中读取了另一个未提交的事务中的数据

#### 幻读（又叫：虚读）

一个事务执行两次查询，第二次的结果与第一次结果不一致（出现没有或者已经被删除的行数据），是因为另一个事务在两次查询之间插入或者删除了数据造成的。幻读是事务非独立执行时发生的一种现象

#### 不可重复读

一个事务两次读取了同一行数据，结果得到不同状态的数据，中间正好另一个事务更新了该数据，两次结果相异



### 不可重复读 与 脏读 的区别

脏读是某一事务读取了另一个事务未提交的数据（脏数据），而不可重复读则是读取另一个事务已经提交了的数据

### 不可重复读 与 幻读 的区别

两者都是读取了另一个事务已经提交了的数据，不同的是，不可重复读查询的都是同一个数据项（同一条记录），而幻读针对的是一批数据整体（如数据的个数）



# 数据库事务隔离级别

有4种事务隔离级别，由低到高分别：

- Read uncommitted（读未提交）：最低的隔离级别，任何情况都无法保证，就是一个事务可以读取另一个事务未提交的数据
- Read committed（读提交）：可以避免脏读的发生，就是一个事务要等到另一个事务提交后才能读取数据
- Repeatable read（重复读）：可以避免脏读、不可重复读的发生，就是开始读取数据（事务开启）时，不再允许修改（update）操作；**注意**，这里是不允许update，但是允许insert，所以还是会有可能出现幻读问题
- Serializable（序列化）：可以避免脏读、不可重复读、幻读的发生，最高的隔离级别，就是所有事务串行化顺序执行，但是效率低下，消耗数据库性能，一般不采用

### 主流数据库的默认事务隔离级别

- Read committed：SQL Server，Oracle
- Repeatable read：MySQL



# 分布式事务

在分布式系统中一次操作由多个系统协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为 **分布式事务**

### CAP理论

分布式系统在设计时只能在以下3种中同时满足2种，无法兼顾3种

- 一致性（Consistency）
- 可用性（Availability）
- 分区容错性（Partition Tolerance）

CAP理论是分布式事务处理的理论基础

##### CAP组合

- CA：放弃分区容错性，加强一致性和可用性，关系型数据库就是按照CA进行设计的
- CP：放弃可用性，加强一致性和分区容错性，一些强一致性要求的系统按照CP进行设计，比如跨行转账等
- AP：放弃一致性，加强可用性和分区容错性，追求最终一致性，很多NoSQL数据库就是按照AP进行设计的

在分布式系统的设计中，AP方案应用得比较多，即保证可用性与分区容错性，牺牲一致性，这里的一致性，指的是 **强一致性**，AP方案会保证 **最终一致性**



### 分布式事务的解决方案

#### 一、两阶段提交（2PC）

两阶段提交协议是将事务的提交过程分成提交事务请求和执行事务提交两个阶段进行处理，通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务

- 提交事务请求（准备阶段）：协调者询问参与者事务是否执行成功，参与者发回事务执行结果
- 执行事务提交（提交阶段）：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务

##### 存在的问题

> 1. 同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作
> 2. 单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。如果在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作
> 3. 数据不一致：在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是只有部分参与者提交了事务，从而产生数据不一致
> 4. 太过保守：任意一个节点失败就会导致整个事务失败，没有完善的容错机制

#### 二、事务补偿（TCC）

其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作

主要分为以下3个阶段

1. Try 阶段主要是对业务系统做检测及资源预留
2. Confirm 阶段主要是对业务系统做确认提交，Try 阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的，即：只要 Try 成功，Confirm 一定成功
3. Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放

##### 优点

- 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些

##### 缺点

- 缺点还是比较明显的，在2、3步中都有可能失败
- TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理

#### 三、本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中
2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作

##### 优点

- 一种非常经典的实现，避免了分布式事务，实现了最终一致性

##### 缺点

- 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理

#### 四、MQ事务消息

有一些第三方的MQ是支持事务消息的，比如：RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如：RabbitMQ 和 Kafka 都不支持

下面以阿里的 RocketMQ 中间件为例，大致思路如下：

1. 一阶段：Prepared 消息，拿到消息的地址
2. 二阶段：执行本地事务
3. 三阶段：通过第一阶段拿到的地址去访问消息，并修改状态

也就是说需要在业务方法内向消息队列提交 2 次请求，一次发送消息，一次确认消息

如果确认消息发送失败了，RocketMQ 会定期扫描消息集群中的事务消息，这时发现了 Prepared 消息，会向消息发送者确认，所以生产者需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息

这就能保证消息发送与本地事务 **同时成功** 或 **同时失败**

##### 优点

- 实现了最终一致性，不需要依赖本地数据库事务

##### 缺点

- 实现难度大，主流 MQ 不支持，RocketMQ 事务消息部分代码未开源



### 分布式事务总结

通过几种分布式事务解决方案的对比，分布式事务本身是一个技术难题，是 **没有** 一种 **完美的方案** 应对所有的场景的，具体需要根据业务需求和场景进行选择